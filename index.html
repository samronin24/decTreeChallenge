<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.22">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Decision Tree Challenge</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="index_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="index_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting-cd7454b418030687c631a6a7286fbe16.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#decision-tree-challenge---feature-importance-and-variable-encoding-link-to-discussion" id="toc-decision-tree-challenge---feature-importance-and-variable-encoding-link-to-discussion" class="nav-link active" data-scroll-target="#decision-tree-challenge---feature-importance-and-variable-encoding-link-to-discussion">üå≥ Decision Tree Challenge - Feature Importance and Variable Encoding Link to Discussion</a>
  <ul class="collapse">
  <li><a href="#the-ames-housing-dataset" id="toc-the-ames-housing-dataset" class="nav-link" data-scroll-target="#the-ames-housing-dataset">The Ames Housing Dataset üè†</a></li>
  <li><a href="#the-problem-zipcode-as-numerical-vs-categorical" id="toc-the-problem-zipcode-as-numerical-vs-categorical" class="nav-link" data-scroll-target="#the-problem-zipcode-as-numerical-vs-categorical">The Problem: ZipCode as Numerical vs Categorical</a></li>
  <li><a href="#data-loading-and-model-building" id="toc-data-loading-and-model-building" class="nav-link" data-scroll-target="#data-loading-and-model-building">Data Loading and Model Building</a></li>
  <li><a href="#tree-visualization" id="toc-tree-visualization" class="nav-link" data-scroll-target="#tree-visualization">Tree Visualization</a></li>
  <li><a href="#feature-importance-analysis" id="toc-feature-importance-analysis" class="nav-link" data-scroll-target="#feature-importance-analysis">Feature Importance Analysis</a></li>
  <li><a href="#critical-analysis-the-encoding-problem" id="toc-critical-analysis-the-encoding-problem" class="nav-link" data-scroll-target="#critical-analysis-the-encoding-problem">Critical Analysis: The Encoding Problem</a></li>
  <li><a href="#proper-categorical-encoding-the-solution" id="toc-proper-categorical-encoding-the-solution" class="nav-link" data-scroll-target="#proper-categorical-encoding-the-solution">Proper Categorical Encoding: The Solution</a>
  <ul class="collapse">
  <li><a href="#categorical-encoding-analysis" id="toc-categorical-encoding-analysis" class="nav-link" data-scroll-target="#categorical-encoding-analysis">Categorical Encoding Analysis</a></li>
  <li><a href="#tree-visualization-categorical-zipcode" id="toc-tree-visualization-categorical-zipcode" class="nav-link" data-scroll-target="#tree-visualization-categorical-zipcode">Tree Visualization: Categorical zipCode</a></li>
  <li><a href="#feature-importance-categorical-zipcode" id="toc-feature-importance-categorical-zipcode" class="nav-link" data-scroll-target="#feature-importance-categorical-zipcode">Feature Importance: Categorical zipCode</a></li>
  </ul></li>
  <li><a href="#sec-discussion" id="toc-sec-discussion" class="nav-link" data-scroll-target="#sec-discussion">Discussion Questions for Challenge</a>
  <ul class="collapse">
  <li><a href="#given-what-i-know-about-zip-codes-and-real-estate-prices-zip-code-should-be-modelled-as-categorical-because-when-the-zipcode-is-treated-as-numerical-the-tree-ends-up-splitting-for-example-zipcode-50012.5.-this-does-not-make-sense-because-zip-code-of-50013-is-not-greater-than-50012-in-terms-of-house-prices.-logially-zip-codes-do-play-a-significant-role-in-prediciting-house-prices-as-zip-codes-with-more-income-tend-to-have-houses-that-are-worth-more.-on-the-other-hand-the-right-way-to-model-zip-code-would-be-categorical-where-we-treat-it-as-discrete-cateogies.-when-zipcode-is-numerical-the-feature-importance-ranks-zipcode-very-low-whereas-when-zipcode-is-categorical-there-is-high-importance-as-it-becomes-one-of-the-most-important-features.-moreover-when-zip-codes-are-treated-as-categories-the-decision-tree-can-split-on-zipcode-50010-vs-zipcode50010-and-make-clear-distinctions-on-different-neightborhoods.-in-regards-to-real-estate-prices-it-would-be-a-wrong-business-decision-to-use-numerical-encoding-since-you-would-conclude-location-does-not-matter-for-house-prices.-therefore-data-scientists-should-be-very-careful-on-how-they-prepare-their-data-as-it-can-lead-to-a-common-mistake-that-makes-wrong-business-insights." id="toc-given-what-i-know-about-zip-codes-and-real-estate-prices-zip-code-should-be-modelled-as-categorical-because-when-the-zipcode-is-treated-as-numerical-the-tree-ends-up-splitting-for-example-zipcode-50012.5.-this-does-not-make-sense-because-zip-code-of-50013-is-not-greater-than-50012-in-terms-of-house-prices.-logially-zip-codes-do-play-a-significant-role-in-prediciting-house-prices-as-zip-codes-with-more-income-tend-to-have-houses-that-are-worth-more.-on-the-other-hand-the-right-way-to-model-zip-code-would-be-categorical-where-we-treat-it-as-discrete-cateogies.-when-zipcode-is-numerical-the-feature-importance-ranks-zipcode-very-low-whereas-when-zipcode-is-categorical-there-is-high-importance-as-it-becomes-one-of-the-most-important-features.-moreover-when-zip-codes-are-treated-as-categories-the-decision-tree-can-split-on-zipcode-50010-vs-zipcode50010-and-make-clear-distinctions-on-different-neightborhoods.-in-regards-to-real-estate-prices-it-would-be-a-wrong-business-decision-to-use-numerical-encoding-since-you-would-conclude-location-does-not-matter-for-house-prices.-therefore-data-scientists-should-be-very-careful-on-how-they-prepare-their-data-as-it-can-lead-to-a-common-mistake-that-makes-wrong-business-insights." class="nav-link" data-scroll-target="#given-what-i-know-about-zip-codes-and-real-estate-prices-zip-code-should-be-modelled-as-categorical-because-when-the-zipcode-is-treated-as-numerical-the-tree-ends-up-splitting-for-example-zipcode-50012.5.-this-does-not-make-sense-because-zip-code-of-50013-is-not-greater-than-50012-in-terms-of-house-prices.-logially-zip-codes-do-play-a-significant-role-in-prediciting-house-prices-as-zip-codes-with-more-income-tend-to-have-houses-that-are-worth-more.-on-the-other-hand-the-right-way-to-model-zip-code-would-be-categorical-where-we-treat-it-as-discrete-cateogies.-when-zipcode-is-numerical-the-feature-importance-ranks-zipcode-very-low-whereas-when-zipcode-is-categorical-there-is-high-importance-as-it-becomes-one-of-the-most-important-features.-moreover-when-zip-codes-are-treated-as-categories-the-decision-tree-can-split-on-zipcode-50010-vs-zipcode50010-and-make-clear-distinctions-on-different-neightborhoods.-in-regards-to-real-estate-prices-it-would-be-a-wrong-business-decision-to-use-numerical-encoding-since-you-would-conclude-location-does-not-matter-for-house-prices.-therefore-data-scientists-should-be-very-careful-on-how-they-prepare-their-data-as-it-can-lead-to-a-common-mistake-that-makes-wrong-business-insights.">Given what I know about zip codes and real estate prices, zip code should be modelled as categorical because when the zipcode is treated as numerical, the tree ends up splitting for example ‚Äúzipcode &gt;50012.5‚Äù. This does not make sense because zip code of 50013 is not ‚Äúgreater than‚Äù 50012 in terms of house prices. Logially, zip codes do play a significant role in prediciting house prices as zip codes with more income tend to have houses that are worth more. On the other hand, the right way to model zip code would be categorical where we treat it as discrete cateogies. When zipcode is numerical, the feature importance ranks zipcode very low whereas when zipcode is categorical, there is high importance as it becomes one of the most important features. Moreover, when zip codes are treated as categories, the decision tree can split on ‚Äúzipcode=-50010‚Äù vs ‚Äúzipcode==50010‚Äù and make clear distinctions on different neightborhoods. In regards to real estate prices, it would be a wrong business decision to use numerical encoding since you would conclude location does not matter for house prices. Therefore, data scientists should be very careful on how they prepare their data as it can lead to a common mistake that makes wrong business insights.</a></li>
  <li><a href="#r-and-python-differ-in-categorical-variable-handling-because-rs-rpart-package-supports-categorical-variables-and-has-an-algorithm-that-splits-directly-on-categorical-vairable-and-treates-it-as-a-single-feature-for-importance-calculation.-on-the-other-hand-pythons-scikit-learn-requires-all-input-data-to-be-numerical-and-must-use-one-hot-encoding-which-creates-seperaate-binary-columns-for-each-zip-code.-therefore-the-importance-is-spread-across-multiple-dummy-variables.-r-does-a-significantly-better-job-of-modeling-categorical-variables-because-r-creates-meaningful-splits-that-group-related-cateogries-together-but-python-creates-artificial-splits-on-individual-dummy-variables-that-are-harder-to-interpret.-we-can-see-in-feature-importance-that-python-dilutes-importance-across-multiple-dummy-variables-which-is-underestimating-the-true-importance.-r-maintains-reasonable-tree-complexity-with-logical-categorical-splits-whereas-python-creates-overly-complex-trees-with-many-splits-on-dummy-variables.-to-support-my-claim-i-will-provide-a-quote-from-the-documentation-of-the-sklearn.tree.decisiontreeregression-site.-the-quote-says-however-the-scikit-learn-implementation-does-not-support-categorical-variables-for-now.-this-explains-why-python-does-a-worse-job-of-modelling-categorical-variables." id="toc-r-and-python-differ-in-categorical-variable-handling-because-rs-rpart-package-supports-categorical-variables-and-has-an-algorithm-that-splits-directly-on-categorical-vairable-and-treates-it-as-a-single-feature-for-importance-calculation.-on-the-other-hand-pythons-scikit-learn-requires-all-input-data-to-be-numerical-and-must-use-one-hot-encoding-which-creates-seperaate-binary-columns-for-each-zip-code.-therefore-the-importance-is-spread-across-multiple-dummy-variables.-r-does-a-significantly-better-job-of-modeling-categorical-variables-because-r-creates-meaningful-splits-that-group-related-cateogries-together-but-python-creates-artificial-splits-on-individual-dummy-variables-that-are-harder-to-interpret.-we-can-see-in-feature-importance-that-python-dilutes-importance-across-multiple-dummy-variables-which-is-underestimating-the-true-importance.-r-maintains-reasonable-tree-complexity-with-logical-categorical-splits-whereas-python-creates-overly-complex-trees-with-many-splits-on-dummy-variables.-to-support-my-claim-i-will-provide-a-quote-from-the-documentation-of-the-sklearn.tree.decisiontreeregression-site.-the-quote-says-however-the-scikit-learn-implementation-does-not-support-categorical-variables-for-now.-this-explains-why-python-does-a-worse-job-of-modelling-categorical-variables." class="nav-link" data-scroll-target="#r-and-python-differ-in-categorical-variable-handling-because-rs-rpart-package-supports-categorical-variables-and-has-an-algorithm-that-splits-directly-on-categorical-vairable-and-treates-it-as-a-single-feature-for-importance-calculation.-on-the-other-hand-pythons-scikit-learn-requires-all-input-data-to-be-numerical-and-must-use-one-hot-encoding-which-creates-seperaate-binary-columns-for-each-zip-code.-therefore-the-importance-is-spread-across-multiple-dummy-variables.-r-does-a-significantly-better-job-of-modeling-categorical-variables-because-r-creates-meaningful-splits-that-group-related-cateogries-together-but-python-creates-artificial-splits-on-individual-dummy-variables-that-are-harder-to-interpret.-we-can-see-in-feature-importance-that-python-dilutes-importance-across-multiple-dummy-variables-which-is-underestimating-the-true-importance.-r-maintains-reasonable-tree-complexity-with-logical-categorical-splits-whereas-python-creates-overly-complex-trees-with-many-splits-on-dummy-variables.-to-support-my-claim-i-will-provide-a-quote-from-the-documentation-of-the-sklearn.tree.decisiontreeregression-site.-the-quote-says-however-the-scikit-learn-implementation-does-not-support-categorical-variables-for-now.-this-explains-why-python-does-a-worse-job-of-modelling-categorical-variables.">R and Python differ in categorical variable handling because R‚Äôs rpart package supports categorical variables and has an algorithm that splits directly on categorical vairable and treates it as a single feature for importance calculation. On the other hand, Python‚Äôs scikit-learn requires all input data to be numerical and must use one-hot encoding, which creates seperaate binary columns for each zip code. Therefore the importance is spread across multiple dummy variables. R does a significantly better job of modeling categorical variables because R creates meaningful splits that group related cateogries together but Python creates artificial splits on individual dummy variables that are harder to interpret. We can see in feature importance that Python dilutes importance across multiple dummy variables which is underestimating the true importance. R maintains reasonable tree complexity with logical categorical splits whereas Python creates overly complex trees with many splits on dummy variables. To support my claim, I will provide a quote from the documentation of the sklearn.tree.DecisionTreeRegression site. The quote says, ‚ÄúHowever, the scikit-learn implementation does not support categorical variables for now.‚Äù This explains why Python does a worse job of modelling categorical variables.</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Decision Tree Challenge</h1>
<p class="subtitle lead">Feature Importance and Categorical Variable Encoding</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="decision-tree-challenge---feature-importance-and-variable-encoding-link-to-discussion" class="level1">
<h1>üå≥ Decision Tree Challenge - Feature Importance and Variable Encoding <a href="#sec-discussion">Link to Discussion</a></h1>
<p>Let‚Äôs assume we want to predict house prices and understand which features matter most. The key question is: <strong>How does encoding categorical variables as numbers affect our understanding of feature importance?</strong></p>
<section id="the-ames-housing-dataset" class="level2">
<h2 class="anchored" data-anchor-id="the-ames-housing-dataset">The Ames Housing Dataset üè†</h2>
<p>We are analyzing the Ames Housing dataset which contains detailed information about residential properties sold in Ames, Iowa from 2006 to 2010. This dataset is perfect for our analysis because it contains a categorical variable (like zip code) and numerical variables (like square footage, year built, number of bedrooms).</p>
</section>
<section id="the-problem-zipcode-as-numerical-vs-categorical" class="level2">
<h2 class="anchored" data-anchor-id="the-problem-zipcode-as-numerical-vs-categorical">The Problem: ZipCode as Numerical vs Categorical</h2>
<p><strong>Key Question:</strong> What happens when we treat zipCode as a numerical variable in a decision tree? How does this affect feature importance interpretation?</p>
<p><strong>The Issue:</strong> Zip codes (50010, 50011, 50012, 50013) are categorical variables representing discrete geographic areas, i.e.&nbsp;neighborhoods. When treated as numerical, the tree might split on ‚ÄúzipCode &gt; 50012.5‚Äù - which has no meaningful interpretation for house prices. Zip codes are non-ordinal categorical variables meaning they have no inherent order that aids house price prediction (i.e.&nbsp;zip code 99999 is not the priceiest zip code).</p>
</section>
<section id="data-loading-and-model-building" class="level2">
<h2 class="anchored" data-anchor-id="data-loading-and-model-building">Data Loading and Model Building</h2>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>Model built with 7 terminal nodes</code></pre>
</div>
</div>
</section>
<section id="tree-visualization" class="level2">
<h2 class="anchored" data-anchor-id="tree-visualization">Tree Visualization</h2>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/visualize-tree-r-1.png" class="img-fluid figure-img" width="960"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="feature-importance-analysis" class="level2">
<h2 class="anchored" data-anchor-id="feature-importance-analysis">Feature Importance Analysis</h2>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/importance-plot-r-1.png" class="img-fluid figure-img" width="768"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="critical-analysis-the-encoding-problem" class="level2">
<h2 class="anchored" data-anchor-id="critical-analysis-the-encoding-problem">Critical Analysis: The Encoding Problem</h2>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Warning</span>‚ö†Ô∏è The Problem Revealed
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>What to note:</strong> Our decision tree treated <code>zipCode</code> as a numerical variable. This leads to zip code being unimportant. Not surprisingly, because there is no reason to believe allowing splits like ‚ÄúzipCode &lt; 50012.5‚Äù should be beneficial for house price prediction. This false coding of a variable creates several problems:</p>
<ol type="1">
<li><strong>Potentially Meaningless Splits:</strong> A zip code of 50013 is not ‚Äúgreater than‚Äù 50012 in any meaningful way for house prices</li>
<li><strong>False Importance:</strong> The algorithm assigns importance to zipCode based on numerical splits rather than categorical distinctions OR the importance of zip code is completely missed as numerical ordering has no inherent relationship to house prices.</li>
<li><strong>Misleading Interpretations:</strong> We might conclude zipCode is not important when our intuition tells us it should be important (listen to your intuition).</li>
</ol>
<p><strong>The Real Issue:</strong> Zip codes are categorical variables representing discrete geographic areas. The numerical values have no inherent order or magnitude relationship to house prices. These must be modelled as categorical variables.</p>
</div>
</div>
</section>
<section id="proper-categorical-encoding-the-solution" class="level2">
<h2 class="anchored" data-anchor-id="proper-categorical-encoding-the-solution">Proper Categorical Encoding: The Solution</h2>
<p>Now let‚Äôs repeat the analysis with zipCode properly encoded as categorical variables to see the difference.</p>
<section id="categorical-encoding-analysis" class="level3">
<h3 class="anchored" data-anchor-id="categorical-encoding-analysis">Categorical Encoding Analysis</h3>
</section>
<section id="tree-visualization-categorical-zipcode" class="level3">
<h3 class="anchored" data-anchor-id="tree-visualization-categorical-zipcode">Tree Visualization: Categorical zipCode</h3>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/visualize-tree-cat-r-1.png" class="img-fluid figure-img" width="960"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="feature-importance-categorical-zipcode" class="level3">
<h3 class="anchored" data-anchor-id="feature-importance-categorical-zipcode">Feature Importance: Categorical zipCode</h3>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/importance-plot-cat-r-1.png" class="img-fluid figure-img" width="768"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="sec-discussion" class="level2">
<h2 class="anchored" data-anchor-id="sec-discussion">Discussion Questions for Challenge</h2>
<ol type="1">
<li><strong>Numerical vs Categorical Encoding:</strong> There are four models above, two in R and two in Python. For each language, the models differ by how zip code is modelled, either as a numerical variable or as a categorical variable. Given what you know about zip codes and real estate prices, how should zip code be modelled, numerically or categorically?</li>
</ol>
<section id="given-what-i-know-about-zip-codes-and-real-estate-prices-zip-code-should-be-modelled-as-categorical-because-when-the-zipcode-is-treated-as-numerical-the-tree-ends-up-splitting-for-example-zipcode-50012.5.-this-does-not-make-sense-because-zip-code-of-50013-is-not-greater-than-50012-in-terms-of-house-prices.-logially-zip-codes-do-play-a-significant-role-in-prediciting-house-prices-as-zip-codes-with-more-income-tend-to-have-houses-that-are-worth-more.-on-the-other-hand-the-right-way-to-model-zip-code-would-be-categorical-where-we-treat-it-as-discrete-cateogies.-when-zipcode-is-numerical-the-feature-importance-ranks-zipcode-very-low-whereas-when-zipcode-is-categorical-there-is-high-importance-as-it-becomes-one-of-the-most-important-features.-moreover-when-zip-codes-are-treated-as-categories-the-decision-tree-can-split-on-zipcode-50010-vs-zipcode50010-and-make-clear-distinctions-on-different-neightborhoods.-in-regards-to-real-estate-prices-it-would-be-a-wrong-business-decision-to-use-numerical-encoding-since-you-would-conclude-location-does-not-matter-for-house-prices.-therefore-data-scientists-should-be-very-careful-on-how-they-prepare-their-data-as-it-can-lead-to-a-common-mistake-that-makes-wrong-business-insights." class="level3">
<h3 class="anchored" data-anchor-id="given-what-i-know-about-zip-codes-and-real-estate-prices-zip-code-should-be-modelled-as-categorical-because-when-the-zipcode-is-treated-as-numerical-the-tree-ends-up-splitting-for-example-zipcode-50012.5.-this-does-not-make-sense-because-zip-code-of-50013-is-not-greater-than-50012-in-terms-of-house-prices.-logially-zip-codes-do-play-a-significant-role-in-prediciting-house-prices-as-zip-codes-with-more-income-tend-to-have-houses-that-are-worth-more.-on-the-other-hand-the-right-way-to-model-zip-code-would-be-categorical-where-we-treat-it-as-discrete-cateogies.-when-zipcode-is-numerical-the-feature-importance-ranks-zipcode-very-low-whereas-when-zipcode-is-categorical-there-is-high-importance-as-it-becomes-one-of-the-most-important-features.-moreover-when-zip-codes-are-treated-as-categories-the-decision-tree-can-split-on-zipcode-50010-vs-zipcode50010-and-make-clear-distinctions-on-different-neightborhoods.-in-regards-to-real-estate-prices-it-would-be-a-wrong-business-decision-to-use-numerical-encoding-since-you-would-conclude-location-does-not-matter-for-house-prices.-therefore-data-scientists-should-be-very-careful-on-how-they-prepare-their-data-as-it-can-lead-to-a-common-mistake-that-makes-wrong-business-insights.">Given what I know about zip codes and real estate prices, zip code should be modelled as categorical because when the zipcode is treated as numerical, the tree ends up splitting for example ‚Äúzipcode &gt;50012.5‚Äù. This does not make sense because zip code of 50013 is not ‚Äúgreater than‚Äù 50012 in terms of house prices. Logially, zip codes do play a significant role in prediciting house prices as zip codes with more income tend to have houses that are worth more. On the other hand, the right way to model zip code would be categorical where we treat it as discrete cateogies. When zipcode is numerical, the feature importance ranks zipcode very low whereas when zipcode is categorical, there is high importance as it becomes one of the most important features. Moreover, when zip codes are treated as categories, the decision tree can split on ‚Äúzipcode=-50010‚Äù vs ‚Äúzipcode==50010‚Äù and make clear distinctions on different neightborhoods. In regards to real estate prices, it would be a wrong business decision to use numerical encoding since you would conclude location does not matter for house prices. Therefore, data scientists should be very careful on how they prepare their data as it can lead to a common mistake that makes wrong business insights.</h3>
<ol start="2" type="1">
<li><strong>R vs Python Implementation Differences:</strong> When modelling zip code as a categorical variable, the output tree and feature importance differs quite significantly between R and Python. Investigate why this is the case. Which language would you say does a better job of modelling zip code as a categorical variable? Why is this the case? Do you see any documentation suggesting the other language does a better job? If so, please provide a quote from the documentation.</li>
</ol>
</section>
<section id="r-and-python-differ-in-categorical-variable-handling-because-rs-rpart-package-supports-categorical-variables-and-has-an-algorithm-that-splits-directly-on-categorical-vairable-and-treates-it-as-a-single-feature-for-importance-calculation.-on-the-other-hand-pythons-scikit-learn-requires-all-input-data-to-be-numerical-and-must-use-one-hot-encoding-which-creates-seperaate-binary-columns-for-each-zip-code.-therefore-the-importance-is-spread-across-multiple-dummy-variables.-r-does-a-significantly-better-job-of-modeling-categorical-variables-because-r-creates-meaningful-splits-that-group-related-cateogries-together-but-python-creates-artificial-splits-on-individual-dummy-variables-that-are-harder-to-interpret.-we-can-see-in-feature-importance-that-python-dilutes-importance-across-multiple-dummy-variables-which-is-underestimating-the-true-importance.-r-maintains-reasonable-tree-complexity-with-logical-categorical-splits-whereas-python-creates-overly-complex-trees-with-many-splits-on-dummy-variables.-to-support-my-claim-i-will-provide-a-quote-from-the-documentation-of-the-sklearn.tree.decisiontreeregression-site.-the-quote-says-however-the-scikit-learn-implementation-does-not-support-categorical-variables-for-now.-this-explains-why-python-does-a-worse-job-of-modelling-categorical-variables." class="level3">
<h3 class="anchored" data-anchor-id="r-and-python-differ-in-categorical-variable-handling-because-rs-rpart-package-supports-categorical-variables-and-has-an-algorithm-that-splits-directly-on-categorical-vairable-and-treates-it-as-a-single-feature-for-importance-calculation.-on-the-other-hand-pythons-scikit-learn-requires-all-input-data-to-be-numerical-and-must-use-one-hot-encoding-which-creates-seperaate-binary-columns-for-each-zip-code.-therefore-the-importance-is-spread-across-multiple-dummy-variables.-r-does-a-significantly-better-job-of-modeling-categorical-variables-because-r-creates-meaningful-splits-that-group-related-cateogries-together-but-python-creates-artificial-splits-on-individual-dummy-variables-that-are-harder-to-interpret.-we-can-see-in-feature-importance-that-python-dilutes-importance-across-multiple-dummy-variables-which-is-underestimating-the-true-importance.-r-maintains-reasonable-tree-complexity-with-logical-categorical-splits-whereas-python-creates-overly-complex-trees-with-many-splits-on-dummy-variables.-to-support-my-claim-i-will-provide-a-quote-from-the-documentation-of-the-sklearn.tree.decisiontreeregression-site.-the-quote-says-however-the-scikit-learn-implementation-does-not-support-categorical-variables-for-now.-this-explains-why-python-does-a-worse-job-of-modelling-categorical-variables.">R and Python differ in categorical variable handling because R‚Äôs rpart package supports categorical variables and has an algorithm that splits directly on categorical vairable and treates it as a single feature for importance calculation. On the other hand, Python‚Äôs scikit-learn requires all input data to be numerical and must use one-hot encoding, which creates seperaate binary columns for each zip code. Therefore the importance is spread across multiple dummy variables. R does a significantly better job of modeling categorical variables because R creates meaningful splits that group related cateogries together but Python creates artificial splits on individual dummy variables that are harder to interpret. We can see in feature importance that Python dilutes importance across multiple dummy variables which is underestimating the true importance. R maintains reasonable tree complexity with logical categorical splits whereas Python creates overly complex trees with many splits on dummy variables. To support my claim, I will provide a quote from the documentation of the sklearn.tree.DecisionTreeRegression site. The quote says, ‚ÄúHowever, the scikit-learn implementation does not support categorical variables for now.‚Äù This explains why Python does a worse job of modelling categorical variables.</h3>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "Óßã";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>